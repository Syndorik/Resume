/*
 * Id : 20186024
 * Name : Alexandre Allani
 * mm.c - The fastest, least memory-efficient malloc package.
 * 
 *We we'll use a segregated Free list in 2^k 0<=k<=20.
 *

//////// FORMAT OF BLOCKS ////////////

A: Allocated bit

////////////////////////////////////////////ALLOCATED BLOCK\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

             31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    HEADER  |                     BLOCK SIZE                                                             |A |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
            |                                                                                               |
            |                                                                                               |
            |                                        PAYLOAD                                                |
           ...                                                                                              ... 
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    FOOTER  |                     BLOCK SIZE                                                             |A |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

///////////////////////////////////////////////FREE BLOCK\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

             31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    HEADER  |                     BLOCK SIZE                                                             |A |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
            |                                     Predecessor in segregated list                            |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
            |                                     Successor in segregated list                              |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
            |                                        NOTHING                                                |
           ...                                                                                              ... 
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    FOOTER  |                     BLOCK SIZE                                                             |A |
            +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

 */
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>

#include "mm.h"
#include "memlib.h"



/* single word (4) or double word (8) alignment */
#define ALIGNMENT 8
#define WSIZE 4
#define DSIZE 8
#define NEWCHUNCKSIZE (1<<6)
#define CHUNCKSIZE (1<<12)

/* My constans*/ 
#define LISTLIMIT 20


/* My macros*/ 

#define MAX(x,y) ((x)>(y) ? (x) : (y))
#define MIN(x,y) ((x)<(y) ? (x) : (y))


/* Macro from p893 of the book*/
/* Pack a size and allocated bit into a word*/
#define PACK(size,alloc) ((size)|(alloc))

/* Read and write a word at address p */
#define GET(p) (*(unsigned int *) (p))
#define PUT(p,val) (*(unsigned int *) (p) = (val))

/* Read the size and allocated fields from address p */
#define GET_SIZE(p) (GET(p) & ~0x7)
#define GET_ALLOC(p) (GET(p) & 0x1)

/* Given block ptr bp, compute address of ts header and footer*/
#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) -DSIZE)


/* Address of previous and next blocks */

#define NEXT_BLKP(bp) ((char *) (bp) + GET_SIZE(((char *) (bp)-WSIZE)))
#define PREV_BLKP(bp) ((char *) (bp) - GET_SIZE(((char *) (bp) - DSIZE)))

/* Address of the next free block predecessor and successor */
#define PREV_FREE(bp) ((char *) (bp))
#define NEXT_FREE(bp) ((char *) (bp) + WSIZE)

/* For a block pointer give address of predecessor and successor */
#define PRED_ADD(bp) ((char *) GET(PREV_FREE(bp)))
#define SUCC_ADD(bp) ((char *) GET(NEXT_FREE(bp)))


void *seglist[LISTLIMIT];
void* heap_listp;

/* rounds up to the nearest multiple of ALIGNMENT */
#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)


#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))


/* Functions */

static void *extend_heap(size_t word);
static void *coalesce(void* bp);
static void *place(void* bp, size_t bpsize);
static void add_to_free_list(void* bp, size_t size);
static void remove_from_free_list(void* bp);


/*
 extend_heap : extend the heap when required ie in mm_init and when there's not enough space in the heap to do a mm_maloc
*/

static void *extend_heap(size_t word){
    void* bp;
    size_t asize;

    asize = ALIGN(word); // We do the alignement

    if((long) (bp = mem_sbrk(asize))==-1){
        return NULL;
    }

    /* Initialisze free block header/footer and the epilogue header */
    PUT(HDRP(bp),PACK(asize,0));
    PUT(FTRP(bp),PACK(asize,0));
    PUT(HDRP(NEXT_BLKP(bp)),PACK(0,1));

    add_to_free_list(bp,asize);

    return coalesce(bp);

}

static void add_to_free_list(void* bp, size_t size){
    
    int list=0;
    size_t tmp = size;
    void* start_ptr;
    
    /* Looking the index of the segregated list we should look at, for instance if size is between 2^10 and 2^11, we should look at index 10 */

    while((tmp > 1) && (list < (LISTLIMIT -1))){
        list++;
        tmp = tmp>>1;
    }

    start_ptr = seglist[list];
    /* The seglist contains NULL pointer if there's no one in the class */

    if(start_ptr == (void *) NULL){
        seglist[list] = bp;
        PUT(NEXT_FREE(bp),(unsigned int) NULL);
        PUT(PREV_FREE(bp), (unsigned int) NULL); //COUOCO
        return;
    }

    else{
        /*We insert the free block to add, at the begining of the list
          We set the "predecessor in segregated list" and "successor in segregated list" fields of the free block */
        PUT(PREV_FREE(bp), (unsigned int) NULL);
        PUT(NEXT_FREE(bp), (unsigned int) start_ptr);

        /*We set the predecessor in segregated list of the sucessor  */
        PUT(PREV_FREE(start_ptr),(unsigned int) bp);
        seglist[list] = bp;
        return;
    }



}

static void remove_from_free_list(void* bp){

    int list =0;
    size_t tmp = GET_SIZE(HDRP(bp));


    /* Looking the index of the segregated list we should look at, for instance if size is between 2^10 and 2^11, we should look at index 10 */

    while((tmp > 1) && (list < (LISTLIMIT -1))){
        list++;
        tmp = tmp>>1;
    }

    
    /*
      Here we're deleting a special node from the linked list
    */
    if(GET(NEXT_FREE(bp)) == (unsigned int) NULL){
        /* If the successor and predecessor are NULL, then it was the only node in this class*/
        if(GET(PREV_FREE(bp)) == (unsigned int) NULL){
            seglist[list] = (void *) NULL;
        }
        /*If the successor is NULL but the predecessor isn't, then the successor of the predecessor (of bp) will be NULL*/
        else{
            PUT(NEXT_FREE(GET(PREV_FREE(bp))),(unsigned int) NULL);
        }
    }
    else{
        /*If the predecessor is NULL but the successor isn't, then the predecessor of the successor (of bp) will be NULL */
        if(GET(PREV_FREE(bp)) == (unsigned int) NULL){
            PUT(PREV_FREE(GET(NEXT_FREE(bp))),(unsigned int) NULL);
            seglist[list] = (void *) GET(NEXT_FREE(bp));
        }
        /*If the both predecessor and successor aren't NULL, we're not on an edge,
          Then, the successor of the predeccesor (of bp) will be the successor of bp
          And the predecessor of the successor (of bp) will be the predecessor of bp */
        else{
            PUT(NEXT_FREE(GET(PREV_FREE(bp))),GET(NEXT_FREE(bp)));
            PUT(PREV_FREE(GET(NEXT_FREE(bp))),GET(PREV_FREE(bp)));
        }
    }
    return;

}

static void *coalesce(void* bp){
    /* As described in the book we're going to distinguish 3 cases and according to this we're going to coaelse*/
    size_t prevbloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));
    size_t nextbloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
    size_t size = GET_SIZE(HDRP(bp));
    void* ret_ptr;

    if(prevbloc){

        /*If both next block and previous block are not free, then we do nothing*/
        if(nextbloc){
            return bp;
        }
        /* If next block is free, then we remove from free list first both Next block and the current block pointers
           Then we compute the new size and update the footer and header
           We insert the node at the end*/
        else{
            remove_from_free_list(bp);
            remove_from_free_list(NEXT_BLKP(bp));
            size = size + GET_SIZE(HDRP(NEXT_BLKP(bp))); //Don't forget the HDRP Otherwise hard error to debug
            PUT(HDRP(bp), PACK(size,0));
            PUT(FTRP(NEXT_BLKP(bp)),PACK(size,0));
            ret_ptr =bp;

        }
    }
    else{
        /* Here we're doing the same thing as when the nextblock was free, but with the previous one*/
        if(nextbloc){
            remove_from_free_list(bp);
            remove_from_free_list(PREV_BLKP(bp));
            size = size + GET_SIZE(HDRP(PREV_BLKP(bp)));
            PUT(FTRP(bp), PACK(size,0));
            PUT(HDRP(PREV_BLKP(bp)), PACK(size,0));
            ret_ptr= PREV_BLKP(bp);
        }
        /* Finally when both next and previous block are free, we remove everyone from the free list,
           Then we compute the new size
           And we update the header of the Previous block and the footer of the Next block*/
        else{
            remove_from_free_list(bp);
            remove_from_free_list(PREV_BLKP(bp));
            remove_from_free_list(NEXT_BLKP(bp));

            size = size + GET_SIZE(HDRP(PREV_BLKP(bp)))+ GET_SIZE(HDRP(NEXT_BLKP(bp)));
            PUT(HDRP(PREV_BLKP(bp)),PACK(size,0));
            PUT(FTRP(NEXT_BLKP(bp)), PACK(size,0));
            ret_ptr = PREV_BLKP(bp);
        }
    }

    add_to_free_list(ret_ptr, size);
    return ret_ptr;
}

/*
  Now we're going to place a block inside the memory. We're splitting the free block memory if the free block we're going to put our allocated block in is too big.
  Hence we're going to limit fragmentation
*/

static void* place(void* bp, size_t bp_size){
    size_t block_size = GET_SIZE(HDRP(bp));
    size_t diff = block_size - bp_size;
    /*Since we're allocating the block we're deleting it from the free lis */
    remove_from_free_list(bp); 

    /* Splitting algorithm */
    /*If the difference between the size of the block and the size required is lesser than 2*DSIZE, we shouldn't split
      Because we would just have a Footer, (predecessor and successor) => 2 and the Footer. Hence we would not have any space for the free block*/
    if(diff <= 2*DSIZE){
        PUT(HDRP(bp), PACK(block_size,1));
        PUT(FTRP(bp), PACK(block_size, 1));

    }
    else if (bp_size >= 100) {
        // Split block
        PUT(HDRP(bp), PACK(diff, 0));
        PUT(FTRP(bp), PACK(diff, 0));
        PUT(HDRP(NEXT_BLKP(bp)), PACK(bp_size, 1));
        PUT(FTRP(NEXT_BLKP(bp)), PACK(bp_size, 1));
        add_to_free_list(bp, diff);
        return NEXT_BLKP(bp);
        
    }
    else{
        /*First allocate the block*/
        PUT(HDRP(bp), PACK(bp_size,1));
        PUT(FTRP(bp),PACK(bp_size, 1));

        /*Create a new free block*/
        PUT(HDRP(NEXT_BLKP(bp)),PACK(diff,0));
        PUT(FTRP(NEXT_BLKP(bp)),PACK(diff,0));

        /* Insert the new free block in the adequate segregated list*/
        add_to_free_list(NEXT_BLKP(bp),diff);
        //printf("diff =%lu ", diff);
    }

    return bp;

}

/* 
 * mm_init - initialize the malloc package.
 */
int mm_init(void)
{
    
    int list =0;

    /* Initialisation of the segregated list */

    for(list=0; list<LISTLIMIT; list++){
        seglist[list]= NULL;
    }

    /* Create the initial empty heap */

    if((heap_listp = mem_sbrk(4*WSIZE)) == (void *) -1){
        return -1;
    }

    PUT(heap_listp,0);
    PUT(heap_listp+ (1*WSIZE), PACK(DSIZE,1));
    PUT(heap_listp+ (2*WSIZE), PACK(DSIZE,1));
    PUT(heap_listp + (3*WSIZE), PACK(0,1));
    heap_listp += (2*WSIZE);

    /* Extend the heap with a free block of CHUCKSIZE bytes */

    if(extend_heap(CHUNCKSIZE/WSIZE) == NULL){
        return -1;
    }
    return 0;
}




/* 
 * mm_malloc - Allocate a block by incrementing the brk pointer.
 *     Always allocate a block whose size is a multiple of the alignment.
 */
void *mm_malloc(size_t size)
{   
    /*Begining inspired of the book*/
    size_t asize;
    size_t extendsize;
    void* bp = NULL;
    int list =0;

    /*Ignore spurious requests*/

    if(size ==0){
        return NULL;
    }

    /*Adjust block size to include overhad and alignement reqs*/
    if(size < DSIZE){
        asize = 2*DSIZE;
    }else{
        asize = ALIGN(size + DSIZE); //Here size + DSIZE, because DSIZE is the size of the footer and header
    }

    size_t size_seglist= asize;

    /* We're trying to find which segregated list can contain the block */
    while(list<LISTLIMIT){
        if(seglist[list] == NULL){ // If it's NULL then the list for this size is empty
        }
        else if(((size_seglist<=1) && (seglist[list] != NULL)) || (list ==LISTLIMIT -1)){ // (if list == LISTLIMIT -1, this means that it belongs to the last segregated list ie the one that contains every blocks whose size is greater than 2^LISTLIMIT)

        /* Now our purpose is to find inside the segregated list if there's one big enough to hold our block */
            bp = seglist[list];
            while((bp != NULL) && (asize > GET_SIZE(HDRP(bp)))){
                
                /*Here we're getting each time the next element in segregated list. We know that at the
                end of the segregate list is a NULL pointer*/

                bp = (void *) GET(NEXT_FREE(bp));

            }
            if(bp != NULL){
                break; //This means that we have our free block
            }
        }
        size_seglist= size_seglist>>1;
        list++;
    }

    /*if there's nothing that can hold our block, we extend the heap*/
    if(bp == NULL){
        extendsize = MAX(asize,CHUNCKSIZE);
        if((bp = extend_heap(extendsize))== (void *) NULL){
            return NULL;
        }
    }

    
    return place(bp,asize);
}

/*
 * mm_free - Freeing a block does nothing.
 */
void mm_free(void *ptr)
{
    /* Here we simply free the block by changing the header and footer
       We then add it the free list
       And finally we coalesce to avoid fragmentation */
    size_t size = GET_SIZE(HDRP(ptr));
    PUT(HDRP(ptr),PACK(size,0));
    PUT(FTRP(ptr),PACK(size,0));

    add_to_free_list(ptr,size);

    coalesce(ptr);
}

/*
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
 */
void *mm_realloc(void *ptr, size_t size)
{
    void *oldptr = ptr;
    void *newptr;
    size_t copySize;
    
    newptr = mm_malloc(size);
    if (newptr == NULL)
      return NULL;
    copySize = *(size_t *)((char *)oldptr - SIZE_T_SIZE);
    if (size < copySize)
      copySize = size;
    memcpy(newptr, oldptr, copySize);
    mm_free(oldptr);
    return newptr;
}














